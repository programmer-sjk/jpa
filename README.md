# JPA(Java Persistence API)

## 1장. JPA 소개
- JPA는 자바진영의 ORM 기술 표준이다.

### SQL을 직접 다룰 떄 발생하는 문제
- 객체를 DB에 CRUD 하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야 하는 문제가 존재
- 요구사항 변경(컬럼 추가)에 따라 수정해야 할 요소가 너무 많다.

### 패러다임의 불 일치
- 객체와 RDBMS는 지향하는 목적이 서로 다르다. 이것을 객체와 RDBMS의 패러다임 불일치 문제라고 한다.
- 애플리케이션은 자바라는 객체지향 언어로 개발하고 데이터는 RDBMS에 저장해야 한다면 패러다임 불일치 문제를 중간에서 개발자가 해결해야 함.
- 패러다임의 불일치로는 상속, 연관관계(객체는 참조를, 테이블은 외래키), 객체 그래프 탐색 등이 있다.
- 정리하면 객체와 RDBMS는 지향하는 패러다임이 다르고, 이 패러다임을 극복하고자 개발자가 너무 많은 시간과 코드를 소비한다.
- JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.

### JPA란 무엇인가?
- Java Persistence API는 자바 진영의 ORM 기술 표준이다. 애플리케이션과 JDBC 사이에서 동작한다.
- ORM(Object-Relational Mapping)은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.
- ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
- 예를 들어 ORM을 사용하면 객체를 DB에 저장할 때 insert 쿼리를 사용하는 것이 아니라 객체를 저장하면 ORM 프레임워크가
적절한 insert SQL 쿼리를 생성해서 DB에 객체를 저장해준다.
- 성숙한 OOP 언어에는 대부분 ORM 프레임워크 들이 있는데 자바 진영에서는 하이버네이트 프레임워크가 가장 많이 사용된다.
- 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어 졌는데 이것이 바로 JPA다.

#### JPA 장점
- 생산성 (지루하고 반복적인 CRUD를 개발자가 직접 생성하지 않는다.)
- 유지보수 (필드를 추가, 삭제시 개발자가 작성해야 했던 코드를 JPA가 대신 처리해주니까 유지보수 해야 할 코드 수가 줄어듬)
- 패러다임 불 일치 문제 해결 (상속, 연관관계, 객체 그래프 탐색 등을 해결해준다.)
- 벤더 독립성 (JPA를 통해 추상화된 데이터 접근 계층을 제공해 특정 DB 기술에 종속되지 않도록 한다.)

## 3장. 영속성 관리

### 엔티티 매니저 팩토리와 엔티티 매니저
- 엔티티 매니저 팩토리는 여러 스레드가 동시 접근해도 안전하므로 서로 다른 스레드간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가
동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유해서는 안 된다.

### 영속성 컨텍스트 (Persistence Context)
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고 관리할 수 있다.

### 엔티티의 생명주기
- 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속: 영속성 컨텍스트에 저장된 상태
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 삭제된 상태

### 영속성 컨텍스트의 특징
- 영속성 컨텍스트가 엔티티를 관리하면 아래 장점이 있다.
  - 1차 캐시
  - 동일성
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

- **1차 캐시**
  - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라 부르며 영속된 엔티티는 모두 여기에 저장된다.
  - em.find를 실행하면 먼저 1차 캐시에서 엔티티를 찾고 없을 경우 DB에 조회한다. 1차 캐시에 엔티티가 있으면 DB조회 없이 메모리에 있는 엔티티를
    바로 반환한다. 없을 경우 DB에 조회해서 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.
- **동일성**
  - em.find를 반복 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 따라서 둘은 같은 인스턴스이고 동일성을 보장한다.
- **트랜잭션을 지원하는 쓰기 지연**
  - 엔티티 매니저는 트랜잭션을 커밋하기 전까지 내부 쿼리 저장소에 INSERT 쿼리를 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리르 DB에 보내는데
  이를 트랜잭션을 지원하는 쓰기 지연이라 한다.
  - 트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화하는 작업이다.
- **변경 감지**
  - JPA는 엔티티를 영속성 컨텍스트에 보관하는데, 최초 상태를 스냅샷으로 저장해둔다. 
  그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
  - 변경 감지는 영속성 컨텍스트에 의해 관리되는 영속 상태의 엔티티에만 적용된다.
  - 컬럼이 30개 이상이 되면 @DynamicUpdate를 사용한 동적 수정 쿼리가 빠르다. 

### 플러시
- 플러시(flush)는 영속성 컨텍스트의 변경 내용을 DB에 반영한다.
- 영속성 컨텍스트를 플러시 하는 방법은 아래 3가지이다.
  - em.flush 직접 호출
  - 트랜잭션 커밋 시 플러시가 자동 호출된다.
  - JPQL 쿼리 실행 시 플러시가 자동 호출된다.
    - JPA는 JPQL을 이용한 select 쿼리 실행 직전에 영속성 컨텍스트를 flush해서 변경 내용을 DB에 반영해야 한다.

### 정리
- 엔티티 매니저 팩토리를 사용해 엔티티 매니저를 생성한다.
- 영속성 컨텍스트 덕분에 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기지연, 변경감지, 지연 로딩 기능을 사용할 수 있다.
- 일반적으로 트랜잭션을 커밋할 때 영속성 컨텍스트가 플러시되어 변경내용을 DB에 반영한다.
