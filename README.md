# JPA(Java Persistence API)

## 1장. JPA 소개
- JPA는 자바진영의 ORM 기술 표준이다.

### SQL을 직접 다룰 떄 발생하는 문제
- 객체를 DB에 CRUD 하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야 하는 문제가 존재
- 요구사항 변경(컬럼 추가)에 따라 수정해야 할 요소가 너무 많다.

### 패러다임의 불 일치
- 객체와 RDBMS는 지향하는 목적이 서로 다르다. 이것을 객체와 RDBMS의 패러다임 불일치 문제라고 한다.
- 애플리케이션은 자바라는 객체지향 언어로 개발하고 데이터는 RDBMS에 저장해야 한다면 패러다임 불일치 문제를 중간에서 개발자가 해결해야 함.
- 패러다임의 불일치로는 상속, 연관관계(객체는 참조를, 테이블은 외래키), 객체 그래프 탐색 등이 있다.
- 정리하면 객체와 RDBMS는 지향하는 패러다임이 다르고, 이 패러다임을 극복하고자 개발자가 너무 많은 시간과 코드를 소비한다.
- JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.

### JPA란 무엇인가?
- Java Persistence API는 자바 진영의 ORM 기술 표준이다. 애플리케이션과 JDBC 사이에서 동작한다.
- ORM(Object-Relational Mapping)은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.
- ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
- 예를 들어 ORM을 사용하면 객체를 DB에 저장할 때 insert 쿼리를 사용하는 것이 아니라 객체를 저장하면 ORM 프레임워크가
적절한 insert SQL 쿼리를 생성해서 DB에 객체를 저장해준다.
- 성숙한 OOP 언어에는 대부분 ORM 프레임워크 들이 있는데 자바 진영에서는 하이버네이트 프레임워크가 가장 많이 사용된다.
- 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어 졌는데 이것이 바로 JPA다.

#### JPA 장점
- 생산성 (지루하고 반복적인 CRUD를 개발자가 직접 생성하지 않는다.)
- 유지보수 (필드를 추가, 삭제시 개발자가 작성해야 했던 코드를 JPA가 대신 처리해주니까 유지보수 해야 할 코드 수가 줄어듬)
- 패러다임 불 일치 문제 해결 (상속, 연관관계, 객체 그래프 탐색 등을 해결해준다.)
- 벤더 독립성 (JPA를 통해 추상화된 데이터 접근 계층을 제공해 특정 DB 기술에 종속되지 않도록 한다.)

## 3장. 영속성 관리

### 엔티티 매니저 팩토리와 엔티티 매니저
- 엔티티 매니저 팩토리는 여러 스레드가 동시 접근해도 안전하므로 서로 다른 스레드간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가
동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유해서는 안 된다.

### 영속성 컨텍스트 (Persistence Context)
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고 관리할 수 있다.

### 엔티티의 생명주기
- 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속: 영속성 컨텍스트에 저장된 상태
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 삭제된 상태

### 영속성 컨텍스트의 특징
- 영속성 컨텍스트가 엔티티를 관리하면 아래 장점이 있다.
  - 1차 캐시
  - 동일성
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

- **1차 캐시**
  - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라 부르며 영속된 엔티티는 모두 여기에 저장된다.
  - em.find를 실행하면 먼저 1차 캐시에서 엔티티를 찾고 없을 경우 DB에 조회한다. 1차 캐시에 엔티티가 있으면 DB조회 없이 메모리에 있는 엔티티를
    바로 반환한다. 없을 경우 DB에 조회해서 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.
- **동일성**
  - em.find를 반복 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 따라서 둘은 같은 인스턴스이고 동일성을 보장한다.
- **트랜잭션을 지원하는 쓰기 지연**
  - 엔티티 매니저는 트랜잭션을 커밋하기 전까지 내부 쿼리 저장소에 INSERT 쿼리를 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리르 DB에 보내는데
  이를 트랜잭션을 지원하는 쓰기 지연이라 한다.
  - 트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화하는 작업이다.
- **변경 감지**
  - JPA는 엔티티를 영속성 컨텍스트에 보관하는데, 최초 상태를 스냅샷으로 저장해둔다. 
  그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
  - 변경 감지는 영속성 컨텍스트에 의해 관리되는 영속 상태의 엔티티에만 적용된다.
  - 컬럼이 30개 이상이 되면 @DynamicUpdate를 사용한 동적 수정 쿼리가 빠르다. 

### 플러시
- 플러시(flush)는 영속성 컨텍스트의 변경 내용을 DB에 반영한다.
- 영속성 컨텍스트를 플러시 하는 방법은 아래 3가지이다.
  - em.flush 직접 호출
  - 트랜잭션 커밋 시 플러시가 자동 호출된다.
  - JPQL 쿼리 실행 시 플러시가 자동 호출된다.
    - JPA는 JPQL을 이용한 select 쿼리 실행 직전에 영속성 컨텍스트를 flush해서 변경 내용을 DB에 반영해야 한다.

### 정리
- 엔티티 매니저 팩토리를 사용해 엔티티 매니저를 생성한다.
- 영속성 컨텍스트 덕분에 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기지연, 변경감지, 지연 로딩 기능을 사용할 수 있다.
- 일반적으로 트랜잭션을 커밋할 때 영속성 컨텍스트가 플러시되어 변경내용을 DB에 반영한다.

## 4장. 엔티티 매핑

### 기본키 매핑
- 직접 할당: 기본 키를 개발자가 애플리케이션에서 직접 할당한다.
- 자동 생성
  - IDENTITY: 기본 키 생성을 DB에 위임함
  - SEQUENCE: DB 시퀀스를 사용해 기본키를 할당
  - TABLE: 키 생성 테이블을 사용

#### IDENTITY 전략
- 기본 키 생성을 DB에 위임하는 전략
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 그런데 IDENTITY 전략은 엔티티를 DB에 저장해야 식별자를 구할 수 있으므로
em.persist()를 호출하는 즉시 INSERT 쿼리를 호출한다. 따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.

#### SEQUENCE 전략
- 시퀀스는 유일한 값을 순서대로 생성하는 특별한 DB 오브젝트다. 
- 시퀀스를 사용하게 되면 IDENTITY와 내부 동작 방식이 다르다. em.persist를 호출할 때 먼저 DB 시퀀스를 사용해서 식별자를 조회한다.
- 그리고 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다. 이후 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를
DB에 저장한다. 반대로 IDENTITY 방식은 엔티티를 DB에 먼저 저장 후 식별자를 조회해서 엔티티의 식별자에 할당한다.

#### 기본키 매핑 정리
- 직접 할당: em.persist() 호출 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다.
- SEQUENCE: DB 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- TABLE: DB 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- IDENTITY: DB에 엔티티를 저장해서 식별자 값을 획득 한 후 영속성 컨텍스트에 저장한다.

## 5장. 연관관계 매핑 기초
- 객체는 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 객체 그래프 탐색이라 한다.

### 연관관계의 주인
- 양방향 연관관계 매핑 시 지켜야할 규칙이 하나 있는데, 두 연관관계 중 하나를 연관관계의 주인으로 정해야 한다.
- 연관관계의 주인만이 DB의 외래키를 관리(등록, 수정, 삭제) 할 수 있다. 반면에 주인이 아닌 쪽은 읽기만 할 수 있다.
- 어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 된다.
- 주인은 mappedBy 속성을 사용하지 않고 주인이 아니면 mappedBy 속성을 사용해서 속성의 값이 연관관계의 주인을 지정해야 한다.
- 연관관계의 주인은 테이블에 외래키가 있는 곳으로 정해야 한다. 테이블의 다대일, 일대다 관계에서는 항상 다대일이 외래키를 가진다.
따라서 ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다. 그래서 ManyToOne에는 mappedBy 속성이 없다.

### 정리
- 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료됨
- 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가된다.
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향 모두 관리해야 한다.
- 연관관계의 주인은 외래키의 위치와 관련해서 정해야 한다.

## 8장. 프록시와 연관관계 정리

### 프록시
- 비지니스 로직에서 A 엔티티만 사용한다면 연관관계 B, C 등을 조회할 필요가 없다. JPA는 이런 문제를 해결하기 위해 엔티티가 실제로
사용될 떄까지 DB 조회를 지연하는 방법을 제공하는데 이를 지연 로딩이라 부른다.
- 지연 로딩을 사용하려면 실제 엔티티 대신 DB 조회를 지연시킬 수 있는 가짜 객체가 필요한데 이를 프록시 객체라고 한다.
- 프록시 객체는 실제 사용될 때 DB를 조회해서 실제 엔티티 객체를 생성하는데 이를 프록시 객체의 초기화라 부른다.

#### 프록시 특징
- 프록시 객체는 처음 사용할 때 한 번 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해 실제 엔티티에 접근할 수 있다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 DB 조회할 필요가 없으므로 getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환환다.
- 엔티티를 프록시로 조회할 때 식별자 값을 전달하는데 프록시 객체는 이 식별자 값을 보관한다. 따라서 식별자가 
id라면 프록시 객체의 getId를 호출해도 초기화 되지 않는다.

### NULL 제약조건과 조인
- JPA는 연관관계에 대해 join 할때 nullable = true 면 Left Join을, nullable = false면 Innjer Join을 사용한다.
- 만약 OneToMany, ManyToMany 관계라면 nullable과 상관없이 외부 조인한다.
- 즉 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용한다.

### JPA 기본 페치 전략
- ManyToOne, OneToOne은 즉시로딩을 기본으로 사용한다. (해봤자 연관 엔티티가 1개이기 때문에)
- OneToMany, ManyToMany는 지연로딩을 기본으로 사용한다. (연관 엔티티가 수천 수만일 수도 있기 때문에)
- 예를들어 특정 회원이 연관 컬렉션에 데이터르 수만 건 등록했는데, 즉시 로딩이면 해당 회원을 로딩하는 순간 수만 건의 데이터도 로딩된다.
- 추천하는 방법은 기본을 지연 로딩으로 사용하고 필요한 곳에만 즉시 로딩을 사용하여 최적화한다.

## 9장. 값 타입
- JPA의 데이터 타입을 가장 크게 분류하면 엔티티 타입과 값 타입으로 나눌 수 있다.
- 엔티티 타입은 @Entity로 정의하는 객체고 값 타입은 int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체를 말한다.
- 값 타입은 아래 3가지로 나눌수 있다.
  - 기본 값 타입(int , double, Integer, String)
  - 임베디드 타입
  - 컬렉션 값 타입

### 값 타입과 불변 객체
- 임베디드 타입은 실제 인스터스 값을 공유하는 대신 복사해서 사용해야 한다.
- 잡는 기본 타입(int)에 값을 대입하면 값을 복사해서 전달한다. 반대로 객체 타입은 객체에 값을 대입하면 항상 참조값을 전달한다.
- 객체의 공유 참조는 피할 수 없기 때문에 객체의 값을 수정하지 못하게 막자. setter 같은 메소드르 제거하면 공유 참조를 해도 값을
변경하지 못하므로 side effect를 막을 수 있다.
- 한 번 만들면 절대 변경할 수 없는 객체를 불변 객체라고 한다. 불변 객체는 조회는 가능하지만 값을 수정할 수 없다.
- 불변 객체를 만드는 가장 간단한 방법은 생성자로만 값을 설정하고 수정자를 만들지 않으면 된다.

### 값 타입의 비교
- 동일성: 인스턴스의 참조 값을 비교, == 사용
- 동등성: 인스턴스의 값을 비교, equals() 사용

### 값 타입 컬렉션
- 엔티티는 식별자가 있으므로 엔티티의 값을 변경해도 식별자로 DB에 저장된 원본 데이터를 찾아 변경할 수 있다.
- 특정 엔티티에 소속된 값 타입은 값이 변경되어도 DB에서 찾아 값을 변경하기 쉽다. 반대로 값 타입 컬렉션은 보관된 값 타입을 별도의 테이블에 저장한다.
따라서 여기 보관된 값 타입의 값이 변경되면 원본 데이터를 찾기 어렵다는 문제가 있다.
- 이런 문제로 JPA는 값 타입 컬렉션에 값이 변경되면 매핑된 테이블에 연관된 모든 데이터를 삭제하고 현재 값 타입 컬렉션에 객체에 있는 모든 값을 DB에
새로 저장한다.
- 따라서 실무에서는 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신 일대다 관계를 고려해야 한다.
- 실무에서는 값 타입 컬렉션을 사용하는 대신 일대다 관계에 영속성 전이 + 고아 객체 제거 기능을 적용하면 값 타입 컬렉션처럼 사용 가능하다.

### 정리
- 엔티티 타입의 특징은 식별자가 있고 생명주기가 있다.
- 값 타입의 특징은 식별자가 없고 생명주기를 엔티티에 의존한다. 공유하지 않는 것이 안전하고 불변 객체로 만든 것이 좋다.

## 10장. 객체지향 쿼리 언어

### 객체지향 쿼리소개
- EntityManger.find()나 객체 그래프 탐색으로 실무에 필요한 모든 데이터를 제공하긴 힘들다.
- JPA는 다양한 데이터 조회를 위해 공식적으로 아래 기능을 지원한다.
  - JPQL, Criteria 쿼리, 네이티브 SQL
- JPA가 공식지원 하지는 않지만 알아둘 가치가 있다.
  - QueryDSL
- 가장 중요한 건 JPQL이다. Criteria나 QueryDSL은 JPQL을 편하게 작성하도록 도와주는 빌더 클래스이다.

### JPQL
- JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다. SQL을 추상화해서 특정 DB에 의존하지 않는다.
- 엔티티와 속성은 대소문자를 구별하며 반드시 별칭을 써야한다.  
- fetch join에 distinct를 사용하면 SQL의 distinct 기능으로 조회한 결과를 어플리케이션에서 중복 엔티티를 한번 더 걸러준다.
- 일반 조인을 JPQL에 사용하면 단지 SELECT 절에 지정한 엔티티만 조회한다. 반대로 fetch join은 연관된 엔티티를 같이 조회한다.
- fetch join을 사용하면 아래 3가지의 한계가 있다.
  - 페치 조인 대상에는 별칭을 줄 수 없다.
    - JPA 표준이 지원하지는 않지만 몇몇 구현체들은 별칭을 지원한다. 하지만 별칭을 잘못 사용하면 데이터 무결성이 깨질 수 있다.
  - 둘 이상의 컬렉션을 페치할 수 없다.
  - 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.
    - 일대일, 다대일은 페치 조인을 사용해도 페이징 API를 사용할 수 있다.
    - 컬렉션을 페치 조인하고 페이징 API를 사용하면 메모리에서 페이징 처리를 한다. 
    - 데이터가 적으면 괜찮겠지만 데이터가 많다면 성능이슈 + 메모리 초과 예외가 발생할 수 있다.
- fetch join은 객체 그래프를 유지할 때 효과적이며, 여러 테이블을 조인해서 엔티티가 아닌 다른 결과를 내야 한다면 여러 테이블에서 필요한
필드만 조회해서 DTO로 변환하는 것이 더 효과적일 수 있다.

### Criteria 소개
- JPQL을 생성하는 빌더 클래스이다. 문자가 아닌 query.select(m).where(...) 처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 장점이 있다.
- Criteria는 QueryDSL 이전에는 JPQL을 직접 사용하는 것 보다 장점이 있지만 여전히 가독성이 좋지 않으니 QueryDSL을 사용하자.

### QUeryDSL 소개
- JPQL 빌더 역할을 한다. 장점은 코드 기반이기 때문에 컴파일 단계에서 문법 오류를 잡을 수 있고 단순하며 사용하기 쉽다. 

### 네이티브 SQL
- 어떤 이유로 JPQL을 사용할 수 없을 때 JPA는 SQL을 직접 사용할 수 있는 기능을 제공하는데 이를 네이티브 SQL이라 한다.
- 네이티브 SQL을 사용하면 엔티티를 조회할 수 있고 JPA가 지원하는 영속성 컨텍스트의 기능을 그대로 사용할 수 있다. (JDBC는 안됨)

### 영속성 컨텍스트와 JPQL
- JPQL의 조회 대상은 엔티티, 임베디드 타입, 값 타입등 여러 종류가 있다.
- JPQL로 엔티티를 조회하면 영속성 컨텍스트에 관리되지만 엔티티가 아니라면 영속성 컨텍스트에 관리되지 않는다.
- JPQL로 DB에서 조회한 엔티티가 영속성 컨텍스트에 있으면 JPQL은 조회한 결과를 버리고 영속성 컨텍스트에 있는 엔티티를 반환한다.
- JPQL에서 DB를 조회한 엔티티로 대체하는 것이 합리적으로 보이지만, 영속성 컨텍스트에 수정중인 데이터가 사라질 수 있으므로 위험하다.
- JPQL은 항상 DB에 SQL을 실행해서 결과를 조회한다. (em.find는 식별자 값을 넘기기 때문에 영속성 컨텍스트에서 찾기 쉽지만 JPQL은..)

### JPQL과 플러시 모드
- 플러시는 영속성 컨텍스트의 변경사항 DB에 동기화하는 것이다.
- JPQL은 영속성 컨텍스트의 데이터를 고려하지 않고 DB에 조회한다. 따라서 JPQL을 실행하기 전에 영속성 컨텍스트 내용을 DB에 반영해야 함.
- 만약 JPQL을 실행 전에 영속성 컨텍스트의 내용을 반영하지 않으면 수정중인 엔티티가 조회되지 않을 수 있다.
- 플러시 모드는 Auto와 Commit이 있는데 Auto가 기본값으로 커밋 or 쿼리 실행시 플러시한다.

## 13장. 웹 어플리케이션과 영속성 관리

### 트랜잭션 범위의 영속성 컨텍스트
- 스프링 컨테이너는 트랜젹선 범위의 영속성 컨텍스트를 기본으로 사용한다.
- 서비스에서 Transactional 어노테이션을 사용하면 호출한 메소드를 실행하기 전에 스프링의 트랜잭션 AOP가 먼저 실행한다.
- 스프링 트랜잭션 AOP는 메소들 호출하기 직전에 트랜잭션을 실행하고 메소드가 종료되면 트랜잭션을 커밋하면서 종료한다.
- 트랜잭션이 같으면 항상 동일한 영속성 컨텍스트를 사용하고 트랜잭션이 다르면 서로 다른 영속성 컨텍스트를 사용한다.
- 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다.

### 준영속 상태와 지연로딩
- 트랜잭션은 보통 서비스 계층에서 동작하므로 서비스 계층이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트도 종료된다.
- 따라서 조회한 엔티티는 컨트롤러나 뷰 계층에서 준영속 상태가 되는데 연관 객체에 대해 지연로딩이 설정되어 있다면 이를 참조할 떄 예외가 발생한다.
- 준영속 상태의 지연 로딩 문제를 해결하는 방법은
  - 뷰가 필요한 엔티티를 미리 로딩해두는 방법(글로벌 페치 전략 수정, JPQL 페치 조인)
  - OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법

### N+1 문제와 페치 조인
- 위에서 글로벌 페치 전략을 수정해서 즉시 로딩으로 바꿔보자. 그럼 사용하지 않는 엔티티를 로딩하는 문제와 N+1 문제가 발생한다.
- Member <-> Order가 일대다 관계라고 하자. 즉시 로딩에서 JPQL로 조회 된 Order가 10개라면 각각의 Member를 조회하느라
총 11개의 쿼리가 발생한다. JPA가 JPQL을 분석해서 SQL을 생성할 때 글로벌 페치 전략은 참고하지 않고 오직 JPQL 자체만 사용한다.
- 페치 조인을 사용하면 조인 대상까지 함께 조회하기 때문에 N+1 문제를 해결하는 현실적인 대안이지만 결국 프레젠테이션 계층이 데이터 접근 계층을
침범하는 문제가 있다. 화면 A는 Order만 쓰고 화면 B는 Order, Member를 쓴다고 가정할 때 Repo에 2가지 메소드를 만들었다.
화면 A를 위한 findOrder, 화면 B를 위한 findOrderWithMember. 이렇게 뷰와 Repo 간에 논리적인 의존관계가 발생하는 문제가 있다.

### 준영속 상태와 지연로딩의 문제점
- 준영속 상태에서 지연 로딩 문제를 극복하기 위해 글로벌 페치 전략도 수정하고 JPQL 페치 조인도 사용법을 알아보았다.
- 결국 문제는 엔티티가 프리젠테이션 계층까지 준영속 상태이기 떄문에 발생한다. 영속성 컨텍스트를 뷰까지 열어두고 뷰에서 지연로딩이 가능하게 
하는데 이것이 OSIV다.

### OSIV(Open Session In View)
- OSIV는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻이다. 따라서 뷰에서 지연로딩을 사용할 수 있다.
- 과거의 OSIV는 요청마다 스프링 인터셉터에서 영속성 컨텍스트르 만들어서 트랜잭션을 시작하고 요청이 끝날 때 영속성 컨텍스트를 종료한다.
- 과거의 OSIV가 가지는 문제점은 프리젠테이션 계층에서 엔티티를 변경할 수 있다는 점이다. 예를 들어 보안상의 이유로 주민번호를 마스킹 해서 
뷰에 전달한다. 개발자의 의도는 DB 데이터는 그대로 두고 뷰의 데이터만 변경하는 것이었지만 영속성 컨텍스트가 존재하므로 실제 DB에 변경을 가한다.
- 위의 문제로 최근에는 거의 사용하지 않는다. 최근에는 비지니스 계층에서만 트랜잭션을 유지하는 OSIV를 사용하는데 스프링이 제공하는 OSIV가 이 방식이다.
- 스프링이 제공하는 OSIV는 요청이 들어오면 영속성 컨텍스트를 생성하고 트랜잭션은 서비스 단에서 시작하고 서비스가 끝나면 트랜잭션이 종료된다.
따라서 데이터의 변경은 서비스 단에서 이루어지고 뷰에서 엔티티를 지연 로딩해도 영속성 컨텍스트가 살아있기 떄문에 가능하다.
- 스프링이 제공하는 OSIV는 트랜잭션이 종료되는 서비스 단에서 flush 하고 프리젠테이션 단에는 flush 없이 close로 영속성 컨텍스트만 종료한다.

## 14장. 컬렉션과 부가기능

### 컨버터
- 컨버터를 사용하면 엔티티의 값을 변환해서 DB에 저장할 수 있다.
- 예를 들어 회원의 VIP 여부를 boolean 타입을 쓴다고 가정하자. true, false 대신 Y, N으로 변경해서 저장하고 싶다면 컨버터를 사용하면 된다.

### 리스너
- 모든 엔티티를 대상으로 사용자가 언제 삭제했는지 로그를 남겨야 한다고 가정하자. 이때 애플리케이션의 모든 삭제 로직을 찾아 로깅하는 건 비효율적이다.
- JPA 리스너 기능을 사용하면 엔티티 생명주기에 따른 이벤트를 처리할 수 있다. 엔티티 저장/수정/삭제 전 후에 호출된다.

### 엔티티 그래프
- 엔티티 그래프 기능은 엔티티 조회 시점에 연관된 엔티티를 함께 조회하는 기능이다. 
- 엔티티 그래프를 정적으로 정의하는 Named 엔티티 그래프와 동적으로 정의하는 엔티티 그래프가 있다.

## 15장. 고급 주제와 성능 최적화

### 예외 처리
- 예외가 발생해 트랜잭션을 롤백하면 DB 반영사항만 롤백하지 객체의 변경사항까지 원 상태로 복구하지 않는다.
- 스프링 프레임워크는 영속성 컨텍스트 범위에 따라 다른 방법을 사용한다.
- 기본인 트랜잭션당 영속성 컨텍스트를 사용하면 문제가 발생 시, 트랜잭션 AOP 종료시점에 트랜잭션을 롤백하면서 영속성 컨텍스트를 종료하므로 문제가
발생하지 않는다. OSIV처럼 프리젠테이션까지 영속성 컨텍스트를 유지하면 트랜잭션 롤백 시, 영속성 컨텍스트를 초기화하여 잘못된 영속성 컨텍스트를
사용하지 않도록 문제를 예방한다.

### 엔티티 비교
- 테스트에서 @Transactional이 있고 서비스에도 @Transactional이 있다. 기본 전략은 먼저 시작된 트랜잭션이 있으면 그 트랜잭션을 이어받아
사용하고 없으면 새로 시작한다.
- 예를 들어 테스트에도 @Transactional이 있고 서비스에도 @Transactional이 있다. 테스트 코드를 실행할 때 트랜잭션을 생성하고 서비스는
이 트랜잭션을 이어받아 작업을 수행한다. 트랜잭션 종료 시점은 테스트가 끝날때 이므로 동일한 영속성 컨텍스트를 사용하고 
이는 객체의 동일성, 동등성을 보장한다.
- 만약 테스트에 @Transactional이 없다면 테스트에서 서비스 코드 호출이 종료될 때 영속성 컨텍스트도 종료된다. 이 후 서비스 코드에서 레포지터리로
식별자로 이용해서 엔티티를 조회하면 동등성은 보장하지만 동일성은 보장하지 못한다. 테스트에서 레포지터리로 엔티티를 조회할 때 새로운 트랜잭션이 시작
되기 떄문에 저장한 엔티티와 다른 영속성 컨텍스트를 사용하기 떄문이다.

### 프록시 심화 주제
- 프록시는 원본 엔티티를 상속받아 만들어지므로 엔티티를 사용하는 클라이언트에선 프록시인지 원본 엔티티인지 구분 없이 사용이 가능하다.
- 영속성 컨텍스트는 엔티티의 동일성을 보장한다. 그렇다면 프록시로 조회한 엔티티의 동일성도 보장할까? getReference() 함수로 프록시를 조회 후
em.find를 호출하면 프록시를 반환한다. 
- 만약 em.find를 호출하고 getReference를 호출할 경우, 이미 영속성 컨텍스트가 원본 엔티티를 가지고 있으므로 프록시가 아닌 원본 엔티티를 반환한다.
- 프록시는 원본 엔티티를 상속받아 만들어지므로 동일성 비교시 == 대신 instanceOf를 사용해야 한다.

### N+1
- 엔티티의 연관관계가 즉시로딩일 경우 JPQL 사용시 N+1 문제가 발생하고 지연로딩일 경우 연관 엔티티를 사용하는 시점에 N+1 문제가 발생
- N+1 문제를 피할수 있는 방법으로 fetch join, @BatchSize, @Fetch(FetchMode.SUBSELECT) 등의 방법이 있다.
- 모두 지연로딩을 사용하고 성능 최적화가 필요한 곳에는 JPQL 페치 조인을 사용하자.

### 트랜잭션을 지원하는 쓰기 지연과 어플리케이션 확장성
- 트랜잭션을 지원하는 쓰기 지연 덕분에 성능과 개발 편의성이 좋아졌다. 하지만 진짜 장점은 DB 테이블 row에 락을 잡는 시간이 준다는 점이다.
- 아래와 같은 로직이 있다. SQL을 직접 다루면 update 호출 시 DB 테이블 row에 락을 건다. commit이 호출되기 전까지 유지되는 이 lock 때문에
테이블 row을 수정하려는 다른 트랜잭션은 lock이 풀릴 때까지 대기한다.
- JPA는 commit을 해야 DB에 수정 쿼리를 보내기 때문에 쿼리를 보내고 바로 커밋하므로 DB 락이 걸리는 시간을 최소화한다. 
```java
update(member)
logicA();
logicB();
commit();
```
