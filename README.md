# JPA(Java Persistence API)

## 1장. JPA 소개
- JPA는 자바진영의 ORM 기술 표준이다.

### SQL을 직접 다룰 떄 발생하는 문제
- 객체를 DB에 CRUD 하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야 하는 문제가 존재
- 요구사항 변경(컬럼 추가)에 따라 수정해야 할 요소가 너무 많다.

### 패러다임의 불 일치
- 객체와 RDBMS는 지향하는 목적이 서로 다르다. 이것을 객체와 RDBMS의 패러다임 불일치 문제라고 한다.
- 애플리케이션은 자바라는 객체지향 언어로 개발하고 데이터는 RDBMS에 저장해야 한다면 패러다임 불일치 문제를 중간에서 개발자가 해결해야 함.
- 패러다임의 불일치로는 상속, 연관관계(객체는 참조를, 테이블은 외래키), 객체 그래프 탐색 등이 있다.
- 정리하면 객체와 RDBMS는 지향하는 패러다임이 다르고, 이 패러다임을 극복하고자 개발자가 너무 많은 시간과 코드를 소비한다.
- JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.

### JPA란 무엇인가?
- Java Persistence API는 자바 진영의 ORM 기술 표준이다. 애플리케이션과 JDBC 사이에서 동작한다.
- ORM(Object-Relational Mapping)은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.
- ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
- 예를 들어 ORM을 사용하면 객체를 DB에 저장할 때 insert 쿼리를 사용하는 것이 아니라 객체를 저장하면 ORM 프레임워크가
적절한 insert SQL 쿼리를 생성해서 DB에 객체를 저장해준다.
- 성숙한 OOP 언어에는 대부분 ORM 프레임워크 들이 있는데 자바 진영에서는 하이버네이트 프레임워크가 가장 많이 사용된다.
- 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어 졌는데 이것이 바로 JPA다.

#### JPA 장점
- 생산성 (지루하고 반복적인 CRUD를 개발자가 직접 생성하지 않는다.)
- 유지보수 (필드를 추가, 삭제시 개발자가 작성해야 했던 코드를 JPA가 대신 처리해주니까 유지보수 해야 할 코드 수가 줄어듬)
- 패러다임 불 일치 문제 해결 (상속, 연관관계, 객체 그래프 탐색 등을 해결해준다.)
- 벤더 독립성 (JPA를 통해 추상화된 데이터 접근 계층을 제공해 특정 DB 기술에 종속되지 않도록 한다.)

## 3장. 영속성 관리

### 엔티티 매니저 팩토리와 엔티티 매니저
- 엔티티 매니저 팩토리는 여러 스레드가 동시 접근해도 안전하므로 서로 다른 스레드간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가
동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유해서는 안 된다.

### 영속성 컨텍스트 (Persistence Context)
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있고 관리할 수 있다.

### 엔티티의 생명주기
- 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속: 영속성 컨텍스트에 저장된 상태
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 삭제된 상태

### 영속성 컨텍스트의 특징
- 영속성 컨텍스트가 엔티티를 관리하면 아래 장점이 있다.
  - 1차 캐시
  - 동일성
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

- **1차 캐시**
  - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라 부르며 영속된 엔티티는 모두 여기에 저장된다.
  - em.find를 실행하면 먼저 1차 캐시에서 엔티티를 찾고 없을 경우 DB에 조회한다. 1차 캐시에 엔티티가 있으면 DB조회 없이 메모리에 있는 엔티티를
    바로 반환한다. 없을 경우 DB에 조회해서 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.
- **동일성**
  - em.find를 반복 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 따라서 둘은 같은 인스턴스이고 동일성을 보장한다.
- **트랜잭션을 지원하는 쓰기 지연**
  - 엔티티 매니저는 트랜잭션을 커밋하기 전까지 내부 쿼리 저장소에 INSERT 쿼리를 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리르 DB에 보내는데
  이를 트랜잭션을 지원하는 쓰기 지연이라 한다.
  - 트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 플러시한다. 플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화하는 작업이다.
- **변경 감지**
  - JPA는 엔티티를 영속성 컨텍스트에 보관하는데, 최초 상태를 스냅샷으로 저장해둔다. 
  그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
  - 변경 감지는 영속성 컨텍스트에 의해 관리되는 영속 상태의 엔티티에만 적용된다.
  - 컬럼이 30개 이상이 되면 @DynamicUpdate를 사용한 동적 수정 쿼리가 빠르다. 

### 플러시
- 플러시(flush)는 영속성 컨텍스트의 변경 내용을 DB에 반영한다.
- 영속성 컨텍스트를 플러시 하는 방법은 아래 3가지이다.
  - em.flush 직접 호출
  - 트랜잭션 커밋 시 플러시가 자동 호출된다.
  - JPQL 쿼리 실행 시 플러시가 자동 호출된다.
    - JPA는 JPQL을 이용한 select 쿼리 실행 직전에 영속성 컨텍스트를 flush해서 변경 내용을 DB에 반영해야 한다.

### 정리
- 엔티티 매니저 팩토리를 사용해 엔티티 매니저를 생성한다.
- 영속성 컨텍스트 덕분에 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기지연, 변경감지, 지연 로딩 기능을 사용할 수 있다.
- 일반적으로 트랜잭션을 커밋할 때 영속성 컨텍스트가 플러시되어 변경내용을 DB에 반영한다.

## 4장. 엔티티 매핑

### 기본키 매핑
- 직접 할당: 기본 키를 개발자가 애플리케이션에서 직접 할당한다.
- 자동 생성
  - IDENTITY: 기본 키 생성을 DB에 위임함
  - SEQUENCE: DB 시퀀스를 사용해 기본키를 할당
  - TABLE: 키 생성 테이블을 사용

#### IDENTITY 전략
- 기본 키 생성을 DB에 위임하는 전략
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 그런데 IDENTITY 전략은 엔티티를 DB에 저장해야 식별자를 구할 수 있으므로
em.persist()를 호출하는 즉시 INSERT 쿼리를 호출한다. 따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.

#### SEQUENCE 전략
- 시퀀스는 유일한 값을 순서대로 생성하는 특별한 DB 오브젝트다. 
- 시퀀스를 사용하게 되면 IDENTITY와 내부 동작 방식이 다르다. em.persist를 호출할 때 먼저 DB 시퀀스를 사용해서 식별자를 조회한다.
- 그리고 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다. 이후 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를
DB에 저장한다. 반대로 IDENTITY 방식은 엔티티를 DB에 먼저 저장 후 식별자를 조회해서 엔티티의 식별자에 할당한다.

#### 기본키 매핑 정리
- 직접 할당: em.persist() 호출 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다.
- SEQUENCE: DB 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- TABLE: DB 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다.
- IDENTITY: DB에 엔티티를 저장해서 식별자 값을 획득 한 후 영속성 컨텍스트에 저장한다.

## 5장. 연관관계 매핑 기초
- 객체는 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 객체 그래프 탐색이라 한다.

### 연관관계의 주인
- 양방향 연관관계 매핑 시 지켜야할 규칙이 하나 있는데, 두 연관관계 중 하나를 연관관계의 주인으로 정해야 한다.
- 연관관계의 주인만이 DB의 외래키를 관리(등록, 수정, 삭제) 할 수 있다. 반면에 주인이 아닌 쪽은 읽기만 할 수 있다.
- 어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 된다.
- 주인은 mappedBy 속성을 사용하지 않고 주인이 아니면 mappedBy 속성을 사용해서 속성의 값이 연관관계의 주인을 지정해야 한다.
- 연관관계의 주인은 테이블에 외래키가 있는 곳으로 정해야 한다. 테이블의 다대일, 일대다 관계에서는 항상 다대일이 외래키를 가진다.
따라서 ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다. 그래서 ManyToOne에는 mappedBy 속성이 없다.

### 정리
- 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료됨
- 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가된다.
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향 모두 관리해야 한다.
- 연관관계의 주인은 외래키의 위치와 관련해서 정해야 한다.

## 8장. 프록시와 연관관계 정리

### 프록시
- 비지니스 로직에서 A 엔티티만 사용한다면 연관관계 B, C 등을 조회할 필요가 없다. JPA는 이런 문제를 해결하기 위해 엔티티가 실제로
사용될 떄까지 DB 조회를 지연하는 방법을 제공하는데 이를 지연 로딩이라 부른다.
- 지연 로딩을 사용하려면 실제 엔티티 대신 DB 조회를 지연시킬 수 있는 가짜 객체가 필요한데 이를 프록시 객체라고 한다.
- 프록시 객체는 실제 사용될 때 DB를 조회해서 실제 엔티티 객체를 생성하는데 이를 프록시 객체의 초기화라 부른다.

#### 프록시 특징
- 프록시 객체는 처음 사용할 때 한 번 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해 실제 엔티티에 접근할 수 있다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 DB 조회할 필요가 없으므로 getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환환다.
- 엔티티를 프록시로 조회할 때 식별자 값을 전달하는데 프록시 객체는 이 식별자 값을 보관한다. 따라서 식별자가 
id라면 프록시 객체의 getId를 호출해도 초기화 되지 않는다.

### NULL 제약조건과 조인
- JPA는 연관관계에 대해 join 할때 nullable = true 면 Left Join을, nullable = false면 Innjer Join을 사용한다.
- 만약 OneToMany, ManyToMany 관계라면 nullable과 상관없이 외부 조인한다.
- 즉 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용한다.

### JPA 기본 페치 전략
- ManyToOne, OneToOne은 즉시로딩을 기본으로 사용한다. (해봤자 연관 엔티티가 1개이기 때문에)
- OneToMany, ManyToMany는 지연로딩을 기본으로 사용한다. (연관 엔티티가 수천 수만일 수도 있기 때문에)
- 예를들어 특정 회원이 연관 컬렉션에 데이터르 수만 건 등록했는데, 즉시 로딩이면 해당 회원을 로딩하는 순간 수만 건의 데이터도 로딩된다.
- 추천하는 방법은 기본을 지연 로딩으로 사용하고 필요한 곳에만 즉시 로딩을 사용하여 최적화한다.

## 9장. 값 타입
- JPA의 데이터 타입을 가장 크게 분류하면 엔티티 타입과 값 타입으로 나눌 수 있다.
- 엔티티 타입은 @Entity로 정의하는 객체고 값 타입은 int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체를 말한다.
- 값 타입은 아래 3가지로 나눌수 있다.
  - 기본 값 타입(int , double, Integer, String)
  - 임베디드 타입
  - 컬렉션 값 타입

### 값 타입과 불변 객체
- 임베디드 타입은 실제 인스터스 값을 공유하는 대신 복사해서 사용해야 한다.
- 잡는 기본 타입(int)에 값을 대입하면 값을 복사해서 전달한다. 반대로 객체 타입은 객체에 값을 대입하면 항상 참조값을 전달한다.
- 객체의 공유 참조는 피할 수 없기 때문에 객체의 값을 수정하지 못하게 막자. setter 같은 메소드르 제거하면 공유 참조를 해도 값을
변경하지 못하므로 side effect를 막을 수 있다.
- 한 번 만들면 절대 변경할 수 없는 객체를 불변 객체라고 한다. 불변 객체는 조회는 가능하지만 값을 수정할 수 없다.
- 불변 객체를 만드는 가장 간단한 방법은 생성자로만 값을 설정하고 수정자를 만들지 않으면 된다.

### 값 타입의 비교
- 동일성: 인스턴스의 참조 값을 비교, == 사용
- 동등성: 인스턴스의 값을 비교, equals() 사용

### 값 타입 컬렉션
- 엔티티는 식별자가 있으므로 엔티티의 값을 변경해도 식별자로 DB에 저장된 원본 데이터를 찾아 변경할 수 있다.
- 특정 엔티티에 소속된 값 타입은 값이 변경되어도 DB에서 찾아 값을 변경하기 쉽다. 반대로 값 타입 컬렉션은 보관된 값 타입을 별도의 테이블에 저장한다.
따라서 여기 보관된 값 타입의 값이 변경되면 원본 데이터를 찾기 어렵다는 문제가 있다.
- 이런 문제로 JPA는 값 타입 컬렉션에 값이 변경되면 매핑된 테이블에 연관된 모든 데이터를 삭제하고 현재 값 타입 컬렉션에 객체에 있는 모든 값을 DB에
새로 저장한다.
- 따라서 실무에서는 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신 일대다 관계를 고려해야 한다.
- 실무에서는 값 타입 컬렉션을 사용하는 대신 일대다 관계에 영속성 전이 + 고아 객체 제거 기능을 적용하면 값 타입 컬렉션처럼 사용 가능하다.

### 정리
- 엔티티 타입의 특징은 식별자가 있고 생명주기가 있다.
- 값 타입의 특징은 식별자가 없고 생명주기를 엔티티에 의존한다. 공유하지 않는 것이 안전하고 불변 객체로 만든 것이 좋다.
